# My progress into data structure and algorithms

<div align="center">

| DAY    | STATUS | PROBLEM | DESCRIPTION
| :--------:| :-------: | :-------: | :------- |
|  12/12/2025 |  ğŸ˜€  | Find Closest Number to Zero | Solved, but i need to look for some ideas because i could't think how to verify whether the abs(number) was in the list, and when it was true, how to return the greater number  |
|  13/12/2025 |  ğŸ˜€  | Merge Strings Alternately | Solved using string concatenations, after a saw that could be solved using list, reducing the time complexity at O(N), where  N is the length of word1 plus length word2, respectively |
|  14/12/2025 |  ğŸ˜€  | Roman to Integer | I was able to resolve this question without help, but afterwards see other solutions i noticed that i could've solved without a extra IF statement outside the while loop   |
|  14/12/2025 |  ğŸ˜€  | Is Subsequence | Solved without external help, but, i wrote len(s) == 0 and len(t) >= 0; the second condition is unnecessary, because the string length(t) will be zero or greater than zero. Another tweak was len(s) > len(t) rather than len(s) > 0 and len(t) == 0 which i had been written, because the old way wouldn't catch: len(s) = 4; len(t) = 3, for example, causing unnecessary loop  |
|  15/12/2025 |  ğŸ¤”  | Best Time to Buy and Sell Stock | I could think about a solution but the algorithm is still confusing |
|  16/12/2025 |  ğŸ˜€  | Best Time to Buy and Sell Stock | Solved without help, but when i submitted the code i noticed the runtime a little slow, so, after search for ideas, i noticed that i was using function pre-built(max and min) and these calls to functions/methods has a high time cost.The solution was using ternary operation to replace methods call,resulting a faster code|
|  16/12/2025 |  ğŸ˜€  | Longest Common Prefix | Solved without help, but the space complexity could've been O(1).Rather than using an array to append the common characters between the strings, i could have simply returned  `s[:i]`. In the case when common substring is smaller than every string in the list. And returned `strs[0][:i]` when the substring has the same length as every string in the list(in this case, all the strings have the same length)|
|  17/12/2025 |  ğŸ˜€  | Summary Ranges | Solved without help, but after analyze other solutions i noticed that my question in the code was: "Where the range ends", and in the solutions the question was: "What is the range?". My question in the code implies that at the end of the loop i couldn't get the last range, because it doesn't finish yet and I need to check outside loop the last range, implies a double check because the question was: "where ends" and not "what is"|
|  18/12/2025 |  ğŸ˜€  | Product of Array Except Self | Solved with help, I had difficult to visualize the logic of left element X right element.The trick was using a variable start at 1, so the multiplication occurred with the elements, except the actual, making this for left and right, at the end, multiplying the left by the right |
|  19/12/2025 |  ğŸ˜€  |Merge Intervals |Solved without help, and in this case my solution isn't that bad at all, in general, it's good and my logic was similar to other solutions that had a good time and space complexity|
|  20/12/2025 |  ğŸ˜€  |Rotate Image |Solved without help,and in this case I had the idea to transpose the matrix and swap the elements from left to right, which works, and had a good time and space complexity|
|  21/12/2025 |  ğŸ¤”  |Insert Interval |I could think an idea but the algorithm is still confusing|
|  22/12/2025 |  ğŸ˜€  |Insert Interval |Solved with help(hint from leetcode). The idea was using a binary search for find the correct index to insert the new interval, and after that, combine overlapping positions, like the problem 'Merge Intervals'|
|  23/12/2025 |  ğŸ˜€  |Jewels and Stones |Solved without help.The idea was to storage stones characters count and after, get sum  where ith character from jewels exists into count |
|  24/12/2025 |  ğŸ˜€  |Contains Duplicate |Solved without help and was simple solution, just count the occurrences of each number, and if whatever number have the count greater or equals than two, return true, otherwise, return false |
|  24/12/2025 |  ğŸ˜€  |Ransom Note |Solved without help and it was similar to Contains Duplicate, in summary, count the letters from magazine and verify whether the letters count is equal or greater than ransomNote letters count |
|  25/12/2025 |  ğŸ˜€  |Valid Anagram |Solved without help and to achieve constant space was used the array of alphabet positions, but, in general, i could think about a solution |
|  26/12/2025 |  ğŸ˜€  |Maximum Number of Balloons |Solved without help.In this case, I consider that ballon is a generic word,not fixed, so my solution consider any other word, and not only balloon, implying in the solution of `Rearrange Characters to Make Target String` as well  |
|  26/12/2025 |  ğŸ˜€  |Two Sum |Solved without help. The trick was to use a dictionary to track the number index in the array, and after, verify whether the number necessary to sum exists on the dictionary, if so, return the current index and the index storage on the dictionary, if not, continue to search until find the number necessary  |
|  26/12/2025 |  ğŸ˜€  |Two Sum II - Input Array Is Sorted |Solved with help.I needed watch some videos and read some solutions to understand the idea of move left and right, depending of the current sum, but at the end, i could understand the solution  |
|  27/12/2025 |  ğŸ˜€  |Valid Sudoku |Solved with help.I needed help to map from a grip position to a block between 0 and 2, i was using `module( % 3)` operator, but this, give me the position of value inside a grid, and what i needed was a formula to map a value to a grid, to achieve this, is necessary use `// 3`, to give me the block position  |
|  28/12/2025 |  ğŸ˜€  |Group Anagrams |Solved with help. I needed help to convert list to string, and use this string as key to dictionary.I noticed that i could used a tuple, rather than a list, with tuple is faster, but consume more memory, in contrast, the list use less memory but the time is greater, because it's need to loop over the whole list, converting each number to string and appending into a new string.But in the problem, the use of tuple would be preferable, to less time complexity in general  |
|  29/12/2025 |  ğŸ˜€  |Majority Element |Solved without help.In this case the idea was using a counter for each number frequency and at the end, the remain number is the number that most appear  |
|  29/12/2025 |  ğŸ˜€  |Longest Consecutive Sequence |Solved with help.Solved but i noticed after seeing other solutions that i cloud've used set, rather than dic, to improve time complexity, and the logic to search to sequence begin could be improved, checking at the beginning of the loop if num - 1 is not in the set, if true, the begin was found, if false, continue search for the begin, avoiding if statements and while unnecessary, like my code does,improving the time complexity.  |
|  30/12/2025 |  ğŸ˜€  |Squares of a Sorted Array |Solved without help.In this question, understand that the array is sorted is crucial, and move the pointers depending on the comparison between current numbers.  |
|  30/12/2025 |  ğŸ˜€  |Reverse String |Solved without help.The main idea was to visualize the two pointers technique and use that to swap the string positions |
|  31/12/2025 |  ğŸ˜€  |Valid Palindrome |Solved without help.But i noticed that could've been solved with constant time, by verifying if the current characters is alphanumeric, if so, compare them, if not, move the left pointer by one positive if the left element is not alphanumeric, and move right pointer by one negative if the right element is not alphanumeric.Making this, the space will be constant |
|  31/12/2025 |  ğŸ˜€  |3Sum |Solved without help.But the time and space complexity was not good, to solve this i could've been use while to verify equals elements, rather than set, reducing lookups and improving the time complexity |
|  01/01/2026 |  ğŸ˜€  |Container With Most Water |Solved without help.And i'm very proud of myself, because i could make an efficient algorithm in terms of space and time complexity.I use this picture to construct the logic,[check it out](./assets/images/11_leetcode.svg)  |
|  02/01/2026 |  â˜¹ï¸  |Trapping Rain Water | This problem is very hard and i couldn't think anything work, i need to search for help  |
|  03/01/2026 |  ğŸ˜€  |Trapping Rain Water | I watch some videos and read some code and i understood the solution, the problem is hard but the solution using arrays to track the left and right max value was good and i could understand  |
|  03/01/2026 |  ğŸ˜€  |Baseball Game | Solved with help because i was getting the error of not converting a negative number to int because the function `isdigit()` return false if the number contains `-`, to resolve this i needed to use `lstrip("-")` to remove the `-` signal and after, use `isdigit()` to convert the number correctly  |
|  04/01/2026 |  ğŸ˜€  |Valid Parentheses | Solved with help and the trick was: when find a closing parentheses, the top from the stack needs to be the open parentheses of the same type of close parentheses  |
|  04/01/2026 |  ğŸ˜€  |Evaluate Reverse Polish Notation | Solved without help, and in this case, draw the stack and visualize the elements and its positions was essential to come up with the solution  |
|  05/01/2026 |  ğŸ˜€  |Next Greater Element I | Solved with help, the algorithm correctly, using O(len(nums1) + len(nums2)) is pretty complicated , so i search for help|
|  05/01/2026 |  ğŸ˜€  |Daily Temperatures | Solved with help. I used the problem `Next Greater Element I` as start and the idea of travel throughout the reverse list and store the descending order of the elements inside a stack to get the distance from the closest greater element|
|  06/01/2026 |  ğŸ˜€  |Min Stack | Solved with help. I needed help to understand how to track the minimum value as the stack grows, to solved, i use a tuple, that maintain the actual value and the minimum value until the last seen value inserted on the stack, this solution has a disadvantage that the minimum value is replicated multiple times between values inside the stack.To resolve this question of multiple equals values, is to use a stack auxiliary that maintain only one minimum value at the top of the stack, reducing the memory needed|
|  07/01/2026 |  ğŸ˜€  |Remove Duplicates from Sorted List | Solved without help.And in this case, after seen other solutions, it could've been implemented using only one variable, and using this variable, adjust the pointers to capture where the equals numbers finished and updating the next pointer |
|  07/01/2026 |  ğŸ˜€  |Reverse Linked List | Solved without help, and in this case, my solution was pretty the same as the others that I saw.To solve this question, the key was to draw and see the pointers where each needed to be |
|  08/01/2026 |  ğŸ˜€  |Merge Two Sorted Lists | Solved without help.The trick here was to maintain a second list at the head of the first list as response, and at the end, return the next of the list aux, that pointer to the head of the merged lists |
|  08/01/2026 |  ğŸ˜€  |Linked List Cycle | Solved without help.The main idea was to compare the node address and not the value, because could have equals numbers.And the two pointers, slow and fast, was the trick, if has a cycle, the fast pointer will reach the slow pointer, comparing by address |
|  09/01/2026 |  ğŸ˜€  |Middle of the Linked List | Solved without help, and in this case, draw the slow and fast pointer was essential to visualize that slow pointer, at the end of the loop, containing the middle of the linked list |
|  10/01/2026 |  ğŸ˜€  |Remove Nth Node From End of List | Solved without help, draw was the key to visualize the position to stop the pointer and the case when the sum result in negative, indicating that the position requested was the first|
|  11/01/2026 |  ğŸ˜€  |Copy List with Random Pointer | Solved with help.I could understand the problem, and think in a solution using the hashmap to storage (address older node --> address new node) but i couldn't see the solution to storage all the nodes and after that, add the pointer next and random, I tried to add the pointers in one pass, but i understood the solution|
|  12/01/2026 |  ğŸ˜€  |Binary Search | Solved without help, i just forget the condition: `while left <= right`, when the list has only one element, without `<=` the result is wrong|
|  13/01/2026 |  ğŸ˜€  |Search Insert Position | Solved without help.I just could solved this question because i draw i visualized that right + 1 is always the position to store the target value, but, in this case, right + 1 is equals to left, when the value was not found, so, returning right + 1 or left would produce the same result|
|  13/01/2026 |  ğŸ˜€  |First Bad Version | Solved without help.It was pretty similar to `Search Insert Position` so, i just draw and see the logic of left and right, to return left at the end|
|  14/01/2026 |  ğŸ˜€  |Valid Perfect Square | Solved without help.It was simple when drawing and visualize the idea of binary search, in this case, verifying if the current number time itself, is equals to number, if not, continue doing the binary search until find, or return false if this number was not found|
|  14/01/2026 |  ğŸ˜€  |Search a 2D Matrix | Solved without help.My first approach was to do binary search throughout matrix, but i couldn't make anything work, so I change the approach to make a binary search throughout the rows, and discover the row that possible contained the target value, after this, applied the binary search to the whole column that may contain the value.The complexity is `O(log(m) + log(n))` that is the same as `O(log(m.n))` mathematically  |
|  15/01/2026 |  ğŸ˜€  |Find Minimum in Rotated Sorted Array | Solved with help. I couldn't see the solution: when `nums[mid] > nums[right]` this means that a min value is between `mid` and `right`, so, the left pointer is updated, and when  `nums[mid] <= nums[right]` this means that the min value is on the left side, between `left` and `mid`, so right is update to `right = mid`, the reason why right receive `mid` and not `mid - 1` is because `nums[mid]` may be the smallest value |
|  16/01/2026 |  ğŸ˜€  |Search in Rotated Sorted Array | Solved with help. I couldn't think bout the solution using the  `Find Minimum in Rotated Sorted Array` to make a partition, of left and right minimum value, using the partition, verifying which part the value might be, after discover which part, applying the binary search.I couldn't see this solution, but I understood the main idea|
|  16/01/2026 |  ğŸ˜€  |Koko Eating Bananas | Solved with help. I needed help to understand the idea of creating a range from 1 to `max_value(piles)`, but once I see this idea, i could apply binary search to find the minimum value of `k` that is less or equals than `h` and satisfies the condition of `"she can eat all the bananas within h hours"`|
|  18/01/2026 |  ğŸ˜€  |Maximum Average Subarray I | This question was an excellent to understand the sliding window algorithm, and I could see another use, to compute the average|
|  20/01/2026 |  ğŸ˜€  |Max Consecutive Ones III | I had to watch some videos and read some solutions to understand the algorithm and why it works|
|  21/01/2026 |  ğŸ˜€  |Longest Substring Without Repeating Characters | Solved with help. I had difficult to see that, using a hashmap, when i found a key that already exists, this mean that this is the first  duplicated value within that sequence, so i can move forward to the next value, from the first duplicated, repeating this process, maintain the max window would give the right answer |
|  22/01/2026 |  ğŸ˜€  |Longest Repeating Character Replacement | Solved with help. I had difficult to see that i needed to calculate (right - left + 1)[window size] - max_frequency to count how many elements was swapped, so , if this sum is greater than k, this means that the window is invalid, so, the left pointer is incremented and the frequency at left is decremented until the window be valid again, and this process continue, always tracking the max longest by the window size|
|  23/01/2026 |  ğŸ˜€  |Minimum Size Subarray Sum | Solved with help. I had difficult to see the logic of update the min window, inside the loop `window_sum >= target` while the condition is true, because the main point is to find the min window, and this min window could be found while the condition is true  |
|  24/01/2026 |  ğŸ˜€  |Permutation in String | Solved with help. I saw the idea of the fixed window, because the permutation length will always be the length of s1, if exists, so, if i create a fixed window of size s1 and verify is the frequency of each letter in the window is equals to the frequency of each letter in s1, I found the solution, if not, decrement the frequency at left in the s2, and increment the frequency at right in s2, repeating this process, if the permutation exists, will be found  |
|  25/01/2026 |  ğŸ˜€  |Invert Binary Tree | Solved with help. I needed to see a solution to understand, i have difficult at recursion, i'm studying right now, it's hard for me but I'll learn, in this question, the solution makes sense, and i could understand  |
|  26/01/2026 |  ğŸ˜€  |Maximum Depth of Binary Tree | Solved without help. In this question, I needed to draw the tree, and after that, try to visualize the logic to count each node, summing up to the depth of the tree, I have difficult at recursion but i could solve the question using the draw and make sense but i need to practice more, because for me, recursion is difficult, but I made progress ğŸ˜€ |
|  27/01/2026 |  ğŸ˜€  |Balanced Binary Tree | Solved with help. I needed help to understand that i was returning False, and this return wasn't propagated through the whole stack, so, ate the end, the response was None, rather than False, because false was lost in the stack |
|  28/01/2026 |  ğŸ˜€  |Diameter of Binary Tree | Solved with help. I needed help to visualize how to compute the diameter of a tree, that was basically compute the left + right, and get the maximum value from it |
|  29/01/2026 |  ğŸ˜€  |Same Tree | Solved without help. In this question, the use of breadth first search was more easy for me than recursive calls, and using breath first search was only compare the nodes and verifying if the nodes are equals, both in exists and value. |
|  31/01/2026 |  ğŸ˜€  |Symmetric Tree | Solved with help. Using the solution from `same_tree` and `invert_binary_tree` the solution was just combine the two solutions too build the main idea. |
|  04/02/2026 |  ğŸ˜€  |Path Sum | Solved without help. This problem was solved by understanding the recursive calls in a tree problem, i could understand and it seems that i'm starting to understanding trees using recursions |
|  05/02/2026 |  ğŸ˜€  |Subtree of Another Tree | Solved without help. The solution was like a enhanced from the problem `same tree`, because at the end, the target was to find a point in common between the root node,and the subtree root, and after that, verify if the tree from the root node is equals to the subtree, using the same logic as  `same tree`|
|  06/02/2026 |  ğŸ˜€  |Binary Tree Level Order Traversal | Solved with help. I needed help to understand that, each time that the while loop is executed a new level of the tree is computed, so, when inside a loop, is necessary to add a new list to compute the nodes of that level.Another detail is the use of deque, rather then list, because the list has the complexity of `O(n)` to pop the elements, and the deque has the complexity of `O(1)` to remove from the left or the right |
|  07/02/2026 |  ğŸ˜€  |Kth Smallest Element in a BST | Solved with help. The help that I needed was to visualize the use of in-order traversal method, and after that, to adapt to my logic, I needed to implement the iterative approach |

</div>


## Emojis to use

| EMOJI    | DESCRIPTION 
| :--------:| :-------: 
| ğŸ˜€       |   SOLVED  |
| ğŸ¤”       |   IN_PROGRESS  |
| â˜¹ï¸       |   COULDN'T_SOLVE  |